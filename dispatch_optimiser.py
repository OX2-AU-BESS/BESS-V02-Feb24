# -*- coding: utf-8 -*-
"""
Created on Tue Feb 28 11:35:29 2023

This class carries out the dispatch optimisation and the 

@author: SIMULATION
"""
import gc
import pandas               as pd
import pulp                 as p
import time
import os
import csv 
import forecast_forecast    as ff
import csv
import datetime

from pulp       import LpStatus
from datetime   import datetime, timedelta
#carry out optimisation

class dispatch_optimiser:
    def __init__(self, gen, scn, simulation_params):
        
        self.gen                = gen        
        self.scn                = scn        
        self.optimisation_res   = simulation_params['optimisation_res'  ]
        self.gen.load_solar_profile(self.optimisation_res) #inflate solar generation profile to 5 minutes
        self.forecast_res       = simulation_params['forecast_res'      ]    
        self.forecast_data_path = simulation_params['forecast_data_path']
        self.actual_data_path   = simulation_params['actual_data_path'  ]
        self.revenue_method     = simulation_params['revenue_method'    ]
        self.results            = pd.DataFrame(columns=[ 
            'timestamp', 'bess_dsp_energy','solar_dsp_energy','raise6sec', 'raise60sec', 'raise5min', 'raisereg', 'lower6s', 'lower60s', 'lower5min', 'lowerreg',
            'bess_combined', 'SOC_profile','foreRRP_energy','foreRRP_raise6sec', 'foreRRP_raise60sec', 'foreRRP_raise5min', 'foreRRP_raisereg', 'foreRRP_lower6s', 
            'foreRRP_lower60s', 'foreRRP_lower5min', 'foreRRP_lowerreg',"Battery Capacity (MWhr)","Solver Status"]) #'pre_dispatch',
        self.output_directory   = simulation_params['output_directory']
        self.timestamps         = []
        self.bess_dsp_energy    = []
        self.solar_dsp_energy   = []
        self.raise6s            = []
        self.raise60s           = []
        self.raise5min          = []
        self.raisereg           = []
        self.lower6s            = []
        self.lower60s           = []
        self.lower5min          = []
        self.lowerreg           = []        
        self.bess_combined_output=[]
        self.RRP_energy         = []
        self.RRP_raise6s        = []
        self.RRP_raise60s       = []
        self.RRP_raise5min      = []
        self.RRP_raisereg       = []
        self.RRP_lower6s        = []
        self.RRP_lower60s       = []
        self.RRP_lower5min      = []
        self.RRP_lowerregr      = []
        self.foreRRP_enegy      = []
        self.foreRRP_raise6s    = []
        self.foreRRP_raise60s   = []
        self.foreRRP_raise5min  = []
        self.foreRRP_raisereg   = []
        self.foreRRP_lower6s    = []
        self.foreRRP_lower60s   = []
        self.foreRRP_lower5min  = []
        self.foreRRP_lowerreg   = []
        self.SOC_profile        = []
        self.bat_capacity       = []
        self.num_cycles         = 0
        self.init_bat_capacity  = self.gen.bat_capacity
        self.csv_err_count      = 0

    #========================================================================================
    # ============== Selecting solar data for the time stamp ================================        
    def solar_data_select(self, solar_gen_profile, timestamp, opt_len):        
           # ---- Surrent solar profile extends out to 2055. It is a profile generated by Baringa -----------
        solar_gen_profile.index.to_pydatetime()
        matching_index = solar_gen_profile.index.get_loc(timestamp)
        selected_rows  = solar_gen_profile.iloc [matching_index : matching_index+opt_len]
        """
        if end_time_ts > solar_gen_profile.index[-1]:
            end_time=end_time.replace(year=1900)
            inter_time1=solar_gen_profile.index[-1]
            inter_time2=solar_gen_profile.index[0]
            condition1=(solar_gen_profile.index >= start_time_ts) & (solar_gen_profile.index <= inter_time1)
            condition2=(solar_gen_profile.index >= inter_time2) & (solar_gen_profile.index <= end_time)
            portion1=solar_gen_profile[condition1]
            portion2=solar_gen_profile[condition2]
            selected_rows = portion1.append(portion2).reset_index(drop=True) 
        else:
            condition = (solar_gen_profile.index >= start_time_ts) & (solar_gen_profile.index <= end_time_ts)
            selected_rows = solar_gen_profile[condition]
        # select rows based on a start time and length of rows required
        """
        return selected_rows
    
    #========================================================================================
    # ==============  ================================   
    def print_params(self):
        print("Generator Parameters:")
        self.gen.print_params()
        print("\nScenario Parameters:")
        self.scn.print_params()
        print("\nSimulation Parameters:")
        print("optimisation_res:", self.optimisation_res)
        print("forecast_res:", self.forecast_res)
        print("forecast_data_path:", self.forecast_data_path)
        print("revenue_method:", self.revenue_method)
        print("\nResults:")
        print(self.results)
        
    def save_results(self):
        
        # Get current time
        start_time = datetime.strftime(self.scn.start_timestamp, format="%d_%m_%Y")
        # Format current time as string in yyyymmdd - hhmm format
        
        self.results.to_csv(self.output_directory+"\\"+start_time+"dataframe_dispatch_results.csv", index=False)
        pass
        
    #========================================================================================
    # ============== Printing the parameters ================================================
    def optimise_dispatch(self):
        
        data_input="aurora"

        # ------- set start and end times ----------------------------------------
        date_format  = "%d/%m/%Y"
        start_time   = datetime.strptime(self.scn.start_timestamp, date_format)
        end_time     = datetime.strptime(self.scn.end_timestamp  , date_format)
        
        # ------- set time resolution to 1 hour ----------------------------------
        time_resolution = timedelta(minutes=30)
                
        # ------- loop over time frame with set resolution  ----------------------
        current_time = start_time        
        self.results_file_path = self.output_directory+"\\"+start_time.strftime("%Y-%m-%d")+"_"+"_results.csv"
        # Format current time as string in yyyymmdd - hhmm format
         
        self.results = pd.DataFrame(columns=self.results.columns       )
        self.results . to_csv      (self.results_file_path, index=False) 
        
        # ------- generate forecast price using forecast_forecast function !!!---- 
        # this means that each run will have a different forecast profile. -------
        fore_df      = pd.read_csv(self.forecast_data_path)
        if type(fore_df["Timestamp"][0]) == datetime:
            # Type is `datetime`, Handle accordingly
            pass
        else:
            # Type is string
            fore_df['Timestamp'] = pd.to_datetime(fore_df['Timestamp'],format="%d/%m/%Y %H:%M", dayfirst=True)
            pass
        
        fore_df.reset_index(drop=True           , inplace=True          )
        fore_df.set_index  (fore_df["Timestamp"], inplace=True,drop=True)
        fore_df.drop       ('Timestamp', axis=1 , inplace=True          )
        #grouped = fore_df.groupby(pd.Grouper(freq='D'))
        #group_keys = list(grouped.groups.keys())
        group_dates = fore_df.index.to_list()

        # ------- Import/prepare actual price data ------------------------------- 
        actual_df   = pd.read_csv(self.actual_data_path                         )                   
        actual_df   . drop       (index=actual_df.index[0], axis=0, inplace=True)
        actual_df   . reset_index(drop=True,inplace=True                        )
        if data_input == "aurora":
            actual_df.drop       (actual_df.index[0], inplace=True)
            actual_df.reset_index(drop=True,inplace=True          )
            actual_df.rename     (inplace=True,columns={
                                 'Time (UTC)'                     :"Timestamp"      ,
                                 'Wholesale market price'         :'RRP'            ,
                                 'Contingency raise - 6 seconds'  :'RAISE6SECRRP'   ,
                                 'Contingency raise - 60 seconds' :'RAISE60SECRRP'  ,
                                 'Contingency raise - 5 minutes'  :'RAISE5MINRRP'   ,
                                 'Raise regulation'               :'RAISEREGRRP'    ,
                                 'Contingency lower - 6 seconds'  :'LOWER6SECRRP'   ,
                                 'Contingency lower - 60 seconds' :'LOWER60SECRRP'  ,
                                 'Contingency lower - 5 minutes'  :'LOWER5MINRRP'   ,
                                 'Lower regulation'               :'LOWERREGRRP'    })
        elif data_input == "baringa":
            actual_df.rename(inplace=True,columns={
                                 'Period'                         :"Timestamp"      ,
                                 'Wholesale (RRN)'                :'RRP'            ,
                                 'RAISE6SEC'                      :'RAISE6SECRRP'   ,
                                 'RAISE60SEC'                     :'RAISE60SECRRP'  ,
                                 'RAISE5MIN'                      :'RAISE5MINRRP'   ,
                                 'RAISEREG'                       :'RAISEREGRRP'    ,
                                 'LOWER6SEC'                      :'LOWER6SECRRP'   ,
                                 'LOWER60SEC'                     :'LOWER60SECRRP'  ,
                                 'LOWER5MIN'                      :'LOWER5MINRRP'   ,
                                 'LOWERREG'                       :'LOWERREGRRP'    })
       # extract the hour and minute from the timestamp and create a new column with the format 'HH:MM'
       
        lst_cols=['RRP','RAISE6SECRRP','RAISE60SECRRP','RAISE5MINRRP','RAISEREGRRP','LOWER6SECRRP','LOWER60SECRRP','LOWER5MINRRP','LOWERREGRRP']
        for i in lst_cols:
           actual_df[i] = actual_df[i].apply(lambda x: float(x))
        if type(actual_df["Timestamp"][0]) == datetime:
            pass
        else:
            # Type is string
            actual_df['Timestamp'] = pd.to_datetime(actual_df['Timestamp'],format="%Y/%m/%d %H:%M:%S", dayfirst=True)
            pass
        #actual_df.reset_index(drop=True,inplace=True)
        #actual_df.set_index(actual_df["Timestamp"],inplace=True,drop=True)
        #actual_df.drop('Timestamp', axis=1, inplace=True)
        #grouped_act = actual_df.groupby(pd.Grouper(freq='D'))
        
        # ------- Import battery degradation -------------------------------------
        self.scn.start_timestamp= datetime.strptime(self.scn.start_timestamp, '%d/%m/%Y')
        bat_deg_df= pd.read_csv(self.gen.bat_deg_profile)

        # ------- loop used to apply optimiser as each time timestamp is applied--
        while current_time <= end_time: 
            if current_time.month == 2 and current_time.day == 29:
                current_time += time_resolution
                pass
            elif current_time in group_dates:
                matching_index = fore_df.index.get_loc(current_time)
                fore_df_cur    = fore_df  .iloc[matching_index : matching_index+48]
                act_df_cur     = actual_df.iloc[matching_index : matching_index+48]
                start_time_act = time.time()                  
                # calculate dispatch for current time
                print(current_time)
                self.calculate_dispatch(current_time, fore_df_cur, act_df_cur, bat_deg_df)          
                # increment current_time by time_resolution
                current_time += time_resolution
                end_time_act = time.time()
                elapsed_time = end_time_act - start_time_act
            else:
                print("Data not available for the current date nominated \n")
                current_time  += time_resolution
                start_time_act = time.time()
                end_time_act   = time.time()
                elapsed_time   = end_time_act - start_time_act
                pass
            
            print("Elapsed time:", round(elapsed_time,2), "seconds")
            proc_end_time = datetime.fromtimestamp(end_time_act)
            hour = proc_end_time.hour
            minute = proc_end_time.minute
        
            print(f"Current time: {hour}:{minute} \n")
        #print("finished")
           
            
        #return results vector consisting of data frame containing:
            #intermediate dispatch solutions (BESS and solar), 
            #final dispatch (BESS and Solar), 
            #revenue for individual markets, 
            #final price for everything
        
        self.results=pd.DataFrame({'timestamp'              :self.timestamps,
                                   'bess_dsp_energy'        :self.bess_dsp_energy, 
                                   'solar_dsp_energy'       :self.solar_dsp_energy,
                                   'raise6sec'              : self.raise6s, 
                                   'raise60sec'             : self.raise60s, 
                                   'raise5min'              : self.raise5min, 
                                   'raisereg'               : self.raisereg, 
                                   'lower6s'                : self.lower6s, 
                                   'lower60s'               : self.lower60s, 
                                   'lower5min'              : self.lower5min, 
                                   'lowerreg'               : self.lowerreg,
                                   'bess_combined'          : self.bess_combined_output, 
                                   'SOC_profile'            : self.SOC_profile,
                                   'RRP_energy'             : self.RRP_energy,
                                   'RRP_raise6sec'          : self.RRP_raise6s, 
                                   'RRP_raise60sec'         : self.RRP_raise60s, 
                                   'RRP_raise5min'          : self.RRP_raise5min, 
                                   'RRP_raisereg'           : self.RRP_raisereg, 
                                   'RRP_lower6s'            : self.RRP_lower6s, 
                                   'RRP_lower60s'           : self.RRP_lower60s, 
                                   'RRP_lower5min'          : self.RRP_lower5min, 
                                   'RRP_lowerreg'           : self.RRP_lowerreg,
                                   'foreRRP_energy'         : self.foreRRP_energy,
                                   'foreRRP_raise6sec'      : self.foreRRP_raise6s, 
                                   'foreRRP_raise60sec'     : self.foreRRP_raise60s, 
                                   'foreRRP_raise5min'      : self.foreRRP_raise5min, 
                                   'foreRRP_raisereg'       : self.foreRRP_raisereg, 
                                   'foreRRP_lower6s'        : self.foreRRP_lower6s, 
                                   'foreRRP_lower60s'       : self.foreRRP_lower60s, 
                                   'foreRRP_lower5min'      : self.foreRRP_lower5min, 
                                   'foreRRP_lowerreg'       : self.foreRRP_lowerreg,
                                   'Battery Capacity (MWhr)':self.bat_capacity
                                   })
        self.save_results()
        # Get the captured stdout as a string, for logging purposes.
        
        self.results = self.results.drop(self.results.index[0])
        # Restore stdout to the original value
        
        return  self.results 
    

    #========================================================================================
    # ============== Calculate Dispatch =====================================================
    def calculate_dispatch(self, timestamp, forecasts, actuals, bat_deg_df):
        
        #import interpol
        solar_gen_profile = self.gen.solar_gen_profile
        export_limits     = solar_gen_profile.copy()    # interpol.interpolate_profile(self.scn.export_limits, self.optimisation_res)
        export_limits     . loc [:, 'Profile (MW)'] = 0 # export limits are interpreted as offset from the default plant export limit. 
        solar_gen_profile = solar_gen_profile['Profile (MW)']
        
        forecast_price_profile  = forecasts['RRP'          ]
        forecast_RAISE6SEC_RRP  = forecasts['RAISE6SECRRP' ]
        forecast_RAISE60SEC_RRP = forecasts['RAISE60SECRRP']
        forecast_RAISE5MIN_RRP  = forecasts['RAISE5MINRRP' ]
        forecast_RAISEREG_RRP   = forecasts['RAISEREGRRP'  ]
        forecast_LOWER6SEC_RRP  = forecasts['LOWER6SECRRP' ]
        forecast_LOWER60SEC_RRP = forecasts['LOWER60SECRRP']
        forecast_LOWER5MIN_RRP  = forecasts['LOWER5MINRRP' ]
        forecast_LOWERREG_RRP   = forecasts['LOWERREGRRP'  ]
        
        #--------- determine number of intervals in the optimisation period -------
        opt_len = len(forecast_price_profile)
        solar_gen_profile = self.solar_data_select(solar_gen_profile, timestamp, opt_len)


        #-------------------- PROBLEM DEFINITION in PULP --------------------------
        #print("Building problem definitions and variables.....")
        eff  = (1-self.gen.round_trip_efficiency)/2.0 #efficienty offset of typically 5% in both directions              
        prob = p.LpProblem("dispatch", p.LpMaximize)


        #-------------------- define decision variables ---------------------------
        #--------------------------------------------------------------------------
        RANGE             = range(0,opt_len)
        solar_dispatch    = p.LpVariable.dicts('S'  , RANGE, lowBound=0, upBound=self.gen.solar_MW_rating) # define optimisation variables for solar dispatch, include hard limits of inverter capability
        battery_discharge = p.LpVariable.dicts('B_D', RANGE, lowBound=0, upBound=self.gen.bat_max_MW     ) # define optimisation variables for battery inverter dispatch, include hard limits of inverter capability
        battery_charge    = p.LpVariable.dicts('B_C', RANGE, lowBound=self.gen.bat_min_MW, upBound=0     )


        #-------------------- variables for fcas markets --------------------------
        raise6sec   = p.LpVariable.dicts('R_6sec' , RANGE, lowBound=0                                                      , upBound=self.gen.bat_max_MW*self.scn.FCAS_MW_Participation_Cont)
        raise60sec  = p.LpVariable.dicts('R_60sec', RANGE, lowBound=0                                                      , upBound=self.gen.bat_max_MW*self.scn.FCAS_MW_Participation_Cont)
        raise5min   = p.LpVariable.dicts('R_5min' , RANGE, lowBound=0                                                      , upBound=self.gen.bat_max_MW*self.scn.FCAS_MW_Participation_Cont)
        raisereg    = p.LpVariable.dicts('R_Reg'  , RANGE, lowBound=0                                                      , upBound=self.gen.bat_max_MW*self.scn.FCAS_MW_Participation_Reg )
        lower6sec   = p.LpVariable.dicts('L_6sec' , RANGE, lowBound=self.gen.bat_min_MW*self.scn.FCAS_MW_Participation_Cont, upBound=0                                                      )
        lower60sec  = p.LpVariable.dicts('L_60sec', RANGE, lowBound=self.gen.bat_min_MW*self.scn.FCAS_MW_Participation_Cont, upBound=0                                                      )
        lower5min   = p.LpVariable.dicts('L_5min' , RANGE, lowBound=self.gen.bat_min_MW*self.scn.FCAS_MW_Participation_Cont, upBound=0                                                      )
        lowerreg    = p.LpVariable.dicts('L_Reg'  , RANGE, lowBound=self.gen.bat_min_MW*self.scn.FCAS_MW_Participation_Reg , upBound=0                                                      )
        #my_vars = [solar_dispatch,battery_discharge,battery_charge,raise6sec,raise60sec,raise5min,raisereg,lower6sec,lower60sec,lower5min,lowerreg]


        #-------------------- revenue function of merchant plant------------------
        if (self.revenue_method=='merchant'): 
            prob+= p.lpSum(
                         (( (solar_dispatch [j]+battery_discharge[j])*self.gen.mlf_gen
                           +(battery_charge [j]                     )*self.gen.mlf_load)
                                                                                          *self.optimisation_res/60*forecast_price_profile.iloc[j])
                           + (solar_dispatch[j]*self.scn.LGC_price              *self.optimisation_res/60)
                           + (raise6sec     [j]*forecast_RAISE6SEC_RRP  .iloc[j]*self.optimisation_res/60)
                           + (raise60sec    [j]*forecast_RAISE60SEC_RRP .iloc[j]*self.optimisation_res/60)
                           + (raise5min     [j]*forecast_RAISE5MIN_RRP  .iloc[j]*self.optimisation_res/60)
                           + (raisereg      [j]*forecast_RAISEREG_RRP   .iloc[j]*self.optimisation_res/60)
                           + (lower6sec     [j]*forecast_LOWER6SEC_RRP  .iloc[j]*self.optimisation_res/60)
                           + (lower60sec    [j]*forecast_LOWER60SEC_RRP .iloc[j]*self.optimisation_res/60)
                           + (lower5min     [j]*forecast_LOWER5MIN_RRP  .iloc[j]*self.optimisation_res/60)
                           + (lowerreg      [j]*forecast_LOWERREG_RRP   .iloc[j]*self.optimisation_res/60) for j in range(0,opt_len)),"Revenue" 
            
        """ Breakdown of Revenue function for VRET with single export meter:   
        solar_dispatch[j]*0.5*LGC_price #LGCs received from CEC
        +(solar_dispatch[j]+battery_discharge[j]+battery_charge[j])*0.5*forecast_price_profile.iloc[j] #merchant revenue    
        +(solar_dispatch[j]+battery_charge[j])*0.5*0.8*(72-forecast_price_profile.iloc[j]) #CFD applied for Notional Quantity of Energy (NQE under VRET PPA). 
        -(solar_dispatch[j]+battery_charge[j])*0.5*0.8*LGC_price #LGCs given to state under VRET PPA
    """    
    
        #Revenue function of VRET PPA with single connection point:
        # if (self.revenue_method=='VRET_CFD'): 
        #     prob+= p.lpSum(solar_dispatch[j]*opt_len/30*self.scn.LGC_price 
        #                    + (solar_dispatch[j]+battery_discharge[j]+battery_charge[j])*opt_len/30*forecast_price_profile.iloc[j]
        #                    + (solar_dispatch[j]+battery_charge[j])*opt_len/30*0.8*(72-forecast_price_profile.iloc[j])-(solar_dispatch[j]+battery_charge[j])*0.5*0.8*self.scn.LGC_price
        #                    + (fcas_raise[j]*rrpfcasraise_price_profile.iloc[j]*opt_len/30/self.scn.FCAS_occurance) 
        #                    + (-fcas_lower[j]*rrpfcaslower_price_profile.iloc[j]*opt_len/30/self.scn.FCAS_occurance) for j in range(0,opt_len)), "Revenue" 
        
        """ Breakdown of Revenue function for VRET with separate connection point:   
        solar_dispatch[j]*0.5*LGC_price #LGCs received from CEC
        +(solar_dispatch[j]+battery_discharge[j]+battery_charge[j])*0.5*forecast_price_profile.iloc[j] #merchant revenue    
        +(solar_dispatch[j])*0.5*0.8*(72-forecast_price_profile.iloc[j]) #CFD applied for Notional Quantity of Energy (NGE under VRET PPA). 
        -(solar_dispatch[j])*0.5*0.8*LGC_price #LGCs given to state under VRET PPA
    """  
        #Revenue function of VRET PPA with separate connection point: --> Difference is that battery charging does not take away from revenue settles under PPA.
        # if (self.revenue_method=='VRET_CFD_split'): 
        #     prob+= p.lpSum(solar_dispatch[j]*0.5*LGC_price 
        #                    + (solar_dispatch[j]+battery_discharge[j]+battery_charge[j])*0.5*forecast_price_profile.iloc[j] 
        #                    + (fcas_raise[j]*rrpfcasraise_price_profile.iloc[j]/FCAS_occurance) 
        #                    + (fcas_lower[j]*rrpfcaslower_price_profile.iloc[j]/FCAS_occurance) 
        #                    + (solar_dispatch[j])*0.5*0.8*(72-forecast_price_profile.iloc[j])
        #                    - (solar_dispatch[j])*0.5*0.8*LGC_price for j in range(0,opt_len)),"Revenue"
            
        #print("Building problem constraints.....")


        #-------------------- limit discharge to minimum allowable SOC------------
        for i in range(0,opt_len):
            # total cumulated energy taken from Battery at any time must be less or equal to initial SOC* capacity - lower_limit
            prob += p.lpSum( 
                              (
                               (battery_discharge[j]
                              +(self.scn.FCAS_occurance*(raise6sec[j] + raise60sec[j] + raise5min[j] + raisereg[j])))
                                                                                                                     *(1.0+eff)
                              +(battery_charge[j]
                              +(self.scn.FCAS_occurance*(lower6sec[j] + lower60sec[j] + lower5min[j] + lowerreg[j])))
                                                                                                                     *(1.0-eff)
                                                                                                                               )*self.optimisation_res/60 for j in range(0,i+1)
                                                                                                                               
                                                                                                                                                      ) <= (self.gen.SOC-self.gen.min_SOC)*self.gen.bat_capacity     


        #-------------------- limit discharge to maximum allowable SOC------------
        #print("boundary condition 1")
        for i in range(0,opt_len):
            # total cumulated energy taken from Battery at any time must be less or equal to initial SOC* capacity - lower_limit
            prob += p.lpSum(
                             -(
                              (battery_discharge[j]
                              +(self.scn.FCAS_occurance*(raise6sec[j] + raise60sec[j] + raise5min[j] + raisereg[j])))
                                                                                                                     *(1.0+eff)
                              +(battery_charge[j]
                              +(self.scn.FCAS_occurance*(lower6sec[j] + lower60sec[j] + lower5min[j] + lowerreg[j])))
                                                                                                                     *(1.0-eff)
                                                                                                                               )*self.optimisation_res/60 for j in range(0,i+1)

                                                                                                                                                      ) <= (self.gen.max_SOC-self.gen.SOC)*self.gen.bat_capacity     


        #------final SOC must be within target certain error margin around target SOC
        #------energy remaining in battery at end of period must be greater than target_SOC-5%
        #print("boundary condition 1")
        prob += p.lpSum((
                          (battery_discharge[j]
                          +(self.scn.FCAS_occurance*(raise6sec[j] + raise60sec[j] + raise5min[j] + raisereg[j])))
                                                                                                                 *(1.0+eff)
                          +(battery_charge[j]
                          +(self.scn.FCAS_occurance*(lower6sec[j] + lower60sec[j] + lower5min[j] + lowerreg[j])))
                                                                                                                 *(1.0-eff)
                                                                                                                          )*self.optimisation_res/60 for j in range(0,opt_len)
                                                                                                                          
                                                                                                                          ) <= (-self.scn.target_SOC+self.gen.SOC + self.scn.SoC_tolerance)*self.gen.bat_capacity
            
        #------energy remaining in battery must be smaller than initial_target_SOC+5%           
        prob += p.lpSum((
                        (battery_discharge[j]
                        +(self.scn.FCAS_occurance*(raise6sec[j] + raise60sec[j] + raise5min[j] + raisereg[j])))
                                                                                                               *(1.0+eff)
                        +(battery_charge[j]
                        +(self.scn.FCAS_occurance*(lower6sec[j] + lower60sec[j] + lower5min[j] + lowerreg[j])))
                                                                                                               *(1.0-eff)
                                                                                                                         )*self.optimisation_res/60 for j in range(0,opt_len)
                                                                                                                         
                                                                                                                         ) >= (-self.scn.target_SOC+self.gen.SOC - self.scn.SoC_tolerance)*self.gen.bat_capacity 


        #-------------------- optional limit of daily cycles ----------------------
        prob += p.lpSum( (
                         (battery_discharge[j]
                         +(self.scn.FCAS_occurance*(raise6sec[j] + raise60sec[j] + raise5min[j] + raisereg[j])))
                                                                                                                *(1.0+eff)
                         -(battery_charge[j]
                         +(self.scn.FCAS_occurance*(lower6sec[j] + lower60sec[j] + lower5min[j] + lowerreg[j])))
                                                                                                                *(1.0-eff)
                                                                                                                          )*0.5*self.optimisation_res/60/self.gen.bat_capacity for j in range(0,opt_len)
                                                                                                                         
                                                                                                                          )<= ((self.scn.max_cycles)*self.optimisation_res/24)
        
        #-------------------- limits due to solar Energy availability -------------
        for i in range(0,opt_len):
            prob += p.lpSum(solar_dispatch[i]) <= solar_gen_profile.iloc[i] #maximum output of solar is equivalent to maximuma vailable generation from PV panels


        #-------------------- registered limits for plant and battery limits ------
        for i in range(0,opt_len):
            prob += p.lpSum(
                             solar_dispatch   [i]
                            +battery_discharge[i]
                            +battery_charge   [i]
                            +self.scn.FCAS_occurance*(raise6sec[i] + raise60sec[i] + raise5min[i] + raisereg[i])
                            +self.scn.FCAS_occurance*(lower6sec[i] + lower60sec[i] + lower5min[i] + lowerreg[i])
                                                                                                               ) <= self.gen.plant_max_MW
              
            prob += p.lpSum(solar_dispatch[i]+battery_discharge[i]+battery_charge[i]+self.scn.FCAS_occurance*(raise6sec[i] + raise60sec[i] + raise5min[i] + raisereg[i])
                            +self.scn.FCAS_occurance*(lower6sec[i] + lower60sec[i] + lower5min[i] + lowerreg[i])) >= self.gen.plant_min_MW
            
            prob += p.lpSum(solar_dispatch[i]+battery_discharge[i]+battery_charge[i]) <= self.gen.plant_max_MW
            
            prob += p.lpSum(solar_dispatch[i]+battery_discharge[i]+battery_charge[i]) >= self.gen.plant_min_MW
            
            prob += p.lpSum(battery_discharge[i]+raise6sec[i] + raise60sec[i] + raise5min[i] + raisereg[i]) <= self.gen.bat_max_MW
            
            prob += p.lpSum(battery_charge[i] + lower6sec[i] + lower60sec[i] + lower5min[i] + lowerreg[i]) >= self.gen.bat_min_MW
            
        # export limits due to constraints
        for i in range(0,opt_len):
            #max_registered rating times % constraint. the constriant will be in proportion to the proposed bid. 
            #Assuming the price forecast is accurate, up to %constraint x max_rating could be dispatched, by putting in a bid to provide max_rating.
            prob += p.lpSum(solar_dispatch[i]+battery_discharge[i]+battery_charge[i] + raise6sec[i] + raise60sec[i] + raise5min[i] + raisereg[i]
                            + lower6sec[i] + lower60sec[i] + lower5min[i] + lowerreg[i]) <= self.gen.plant_max_MW*(1+export_limits.iloc[i]) 
        
        # prob += p.lpSum((battery_discharge[j]-battery_charge[j]) for j in range(0,48)) => 0
        
        #----------------------SOLVING PROBLEM-------------------------------------
        
        #print("Solving problem.....")
        prob.solve()
        #for v in prob.variables():
        #    print (str(v)+': '+str(v.varValue))
        print("Status:", LpStatus[prob.status])
        const=[]
        for constraint in prob.constraints.values():
            const.append(constraint.name)
        for i in const:
            prob.constraints.pop(i, None)
        #prob.writeLP
        #prob.constraints.remove
        #-------------------Print solution summary---------------------------------
         # The status of the solution is printed to the screen
        #print ("Status:"+ p.LpStatus[prob.status])
        # Each of the variables is printed with itâ€™s resolved optimum value
    
        #for v in prob.variables():
            #print (str(v.name)+ "="+ str(v.varValue))
            #if('B' in v.name):
                # battery_SOC-=v.varValue/(1.0*bat_capacity)
                
            
        # The optimised objective function value is printed to the screen
        #print ("Total Revenue = AUD "+ str(prob.objective.value()) )
        
        #-----------------Write solution to return variables----------------------
        #print("Writing solution to return variables.....")
        #forecast_revenue=prob.objective.value()
        #actual_revenue=0
        solar_dispatch_vec      =[]
        battery_discharge_vec   =[]
        battery_charge_vec      =[]
        battery_dispatch_vec    =[]
        #bat_disp_spot_only=[]
        raise6sec_disp_vec      =[]
        raise60sec_disp_vec     =[]
        raise5min_disp_vec      =[]
        raisereg_disp_vec       =[]
        lower6sec_disp_vec      =[]
        lower60sec_disp_vec     =[]
        lower5min_disp_vec      =[]
        lowerreg_disp_vec       =[]
        SOC_vec                 =[]
        battery_disp    =0
        battery_total   =0
        
        for i in range(0,opt_len):
            for v in prob.variables():
                if(v.name=='B_D_'+str(i)):
                    battery_discharge_vec.append(v.varValue)
                    battery_disp    +=v.varValue
                    battery_total   +=v.varValue

                if(v.name=='B_C_'+str(i)):
                    battery_charge_vec.append(v.varValue)
                    battery_disp    +=v.varValue
                    battery_total   +=v.varValue

                if(v.name=='S_'+str(i)):
                    solar_dispatch_vec.append(v.varValue)

                if(v.name=='R_6sec_'+str(i)):
                    raise6sec_disp_vec.append(v.varValue)
                    battery_total+=self.scn.FCAS_occurance*v.varValue

                if(v.name=='R_60sec_'+str(i)):
                    raise60sec_disp_vec.append(v.varValue)
                    battery_total+=self.scn.FCAS_occurance*v.varValue

                if(v.name=='R_5min_'+str(i)):
                    raise5min_disp_vec.append(v.varValue)
                    battery_total+=self.scn.FCAS_occurance*v.varValue

                if(v.name=='R_Reg_'+str(i)):
                    raisereg_disp_vec.append(v.varValue)
                    battery_total+=self.scn.FCAS_occurance*v.varValue

                if(v.name=='L_6sec_'+str(i)):
                    lower6sec_disp_vec.append(v.varValue)
                    battery_total+=self.scn.FCAS_occurance*v.varValue

                if(v.name=='L_60sec_'+str(i)):
                    lower60sec_disp_vec.append(v.varValue)
                    battery_total+=self.scn.FCAS_occurance*v.varValue

                if(v.name=='L_5min_'+str(i)):
                    lower5min_disp_vec.append(v.varValue)
                    battery_total+=self.scn.FCAS_occurance*v.varValue

                if(v.name=='L_Reg_'+str(i)):
                    lowerreg_disp_vec.append(v.varValue)
                    battery_total+=self.scn.FCAS_occurance*v.varValue
        
        
        battery_dispatch_vec = [a +(c + d + e + f)*self.scn.FCAS_occurance + b + (g + h + i + j)*self.scn.FCAS_occurance for a, b, c, d, e, f, g, h, i, j in zip(battery_discharge_vec  , battery_charge_vec    ,
                                                                                                                                                                 raise6sec_disp_vec     , raise60sec_disp_vec   ,
                                                                                                                                                                 raise5min_disp_vec     , raisereg_disp_vec     ,
                                                                                                                                                                 lower6sec_disp_vec     , lower60sec_disp_vec   ,
                                                                                                                                                                 lower5min_disp_vec     , lowerreg_disp_vec     )]
        battery_energy = [a + b for a, b in zip(battery_discharge_vec, battery_charge_vec)]
        battery_SOC=self.gen.SOC
        
        for bat_out in battery_dispatch_vec:
            if(bat_out  >0):
                battery_SOC-=(self.optimisation_res/60*bat_out)*(1+eff)/self.gen.bat_capacity
                 #actual energy in MWh taken from battery (given dispatch is for 30-minute intervals and not 1h this creates the first factor of 0.5). The second factor of 0.5 is linked to the fact that one full charge from 0 to 100% is only half a cycle (discharge missing to make it a full cycle)
            elif(bat_out<0):
                battery_SOC-=(self.optimisation_res/60*bat_out)*(1-eff)/self.gen.bat_capacity
               
            SOC_vec.append(battery_SOC)
        

        
        #write first value of dispatch solution into result and discard the rest of the dispatch, given it will be re-optimised again..
        
        try:
        
            with open(self.results_file_path, 'a',newline='') as f:
                # write the header row if the file is empty
                if f.tell() == 0:
                    self.results.to_csv(f, header=True, index=False)
                
                new_row = {'timestamp'          :forecasts.index        [0],    'bess_dsp_energy'    :battery_energy         [0],   'solar_dsp_energy':solar_dispatch_vec[0],
                           'raise6sec'          :raise6sec_disp_vec     [0],    'raise60sec'         :raise60sec_disp_vec    [0],   'raise5min':raise5min_disp_vec       [0],
                           'raisereg'           :raisereg_disp_vec      [0],    'lower6s'            :lower6sec_disp_vec     [0],   'lower60s':lower60sec_disp_vec       [0],
                           'lower5min'          :lower5min_disp_vec     [0],    'lowerreg'           :lowerreg_disp_vec      [0],   'bess_combined':battery_dispatch_vec [0],
                           'SOC_profile'        :SOC_vec                [0],    'foreRRP_energy'     :forecast_price_profile [0],
                           'foreRRP_raise6sec'  :forecast_RAISE6SEC_RRP [0],    'foreRRP_raise60sec' :forecast_RAISE60SEC_RRP[0],
                           'foreRRP_raise5min'  :forecast_RAISE5MIN_RRP [0],    'foreRRP_raisereg'   :forecast_RAISEREG_RRP  [0],
                           'foreRRP_lower6s'    :forecast_LOWER6SEC_RRP [0],    'foreRRP_lower60s'   :forecast_LOWER60SEC_RRP[0],
                           'foreRRP_lower5min'  :forecast_LOWER5MIN_RRP [0],     'foreRRP_lowerreg'  :forecast_LOWERREG_RRP  [0],   "Battery Capacity (MWhr)":self.gen.bat_capacity,"Solver Status":LpStatus[prob.status]}
                            # add the new row to the dataframe
                writer = csv.DictWriter(f, fieldnames=new_row)
    
                    # Write the new data to the CSV file
                writer.writerow(new_row)
        except: 
            print(f"{self.results_file_path} couldn't be opened due to an error")
            self.csv_err_count+=1
        
        #----- Assign values to self values to save to csv at optimisation completion------
        self.timestamps.append(forecasts.index[0])
        self.bess_dsp_energy.append(battery_energy[0])
        self.solar_dsp_energy.append(solar_dispatch_vec[0])
        self.raise6s.append(raise6sec_disp_vec[0])
        self.raise60s.append(raise60sec_disp_vec[0])
        self.raise5min.append(raise5min_disp_vec[0])
        self.raisereg.append(raisereg_disp_vec[0])
        self.lower6s.append(lower6sec_disp_vec[0])
        self.lower60s.append(lower60sec_disp_vec[0])
        self.lower5min.append(lower5min_disp_vec[0])
        self.lowerreg.append(lowerreg_disp_vec[0])        
        self.bess_combined_output.append(battery_dispatch_vec[0])
        self.foreRRP_energy.append(forecast_price_profile[0])
        self.foreRRP_raise6s.append(forecast_RAISE6SEC_RRP[0])
        self.foreRRP_raise60s.append(forecast_RAISE60SEC_RRP[0])
        self.foreRRP_raise5min.append(forecast_RAISE5MIN_RRP[0])
        self.foreRRP_raisereg.append(forecast_RAISEREG_RRP[0])
        self.foreRRP_lower6s.append(forecast_LOWER6SEC_RRP[0])
        self.foreRRP_lower60s.append(forecast_LOWER60SEC_RRP[0])
        self.foreRRP_lower5min.append(forecast_LOWER5MIN_RRP[0])
        self.foreRRP_lowerreg.append(forecast_LOWERREG_RRP[0])
        self.RRP_energy.append(actuals["RRP"].iloc[0])
        self.RRP_raise6s.append(actuals['RAISE6SECRRP'].iloc[0])
        self.RRP_raise60s.append(actuals['RAISE60SECRRP'].iloc[0])
        self.RRP_raise5min.append(actuals['RAISE5MINRRP'].iloc[0])
        self.RRP_raisereg.append(actuals['RAISEREGRRP'].iloc[0])
        self.RRP_lower6s.append(actuals['LOWER6SECRRP'].iloc[0])
        self.RRP_lower60s.append(actuals['LOWER60SECRRP'].iloc[0])
        self.RRP_lower5min.append(actuals['LOWER5MINRRP'].iloc[0])
        self.RRP_lowerreg.append(actuals['LOWERREGRRP'].iloc[0])
        self.SOC_profile.append(SOC_vec[0])
        self.bat_capacity.append(self.gen.bat_capacity)
        
    
        self.gen.discharge(self.optimisation_res/60*battery_dispatch_vec[0])
        
        # ---- implement simple degradation model  ---- #
        start_year_diff = self.scn.start_timestamp.year-datetime.strptime(self.scn.overall_start_timestamp, '%d/%m/%Y').year
        if start_year_diff <= 15:
            year = start_year_diff
            matched_row = bat_deg_df.loc[bat_deg_df['Project Year'] == year]
            self.gen.bat_capacity = matched_row['Usable Capacity'].iloc[0]*self.init_bat_capacity 
        elif start_year_diff > 15:
            # Implement that after 15 years the battery is replaced with the original sizeing and degradation begins again at 100%
            year = start_year_diff-15
            matched_row = bat_deg_df.loc[bat_deg_df['Project Year'] == year]
            self.gen.bat_capacity = matched_row['Usable Capacity'].iloc[0]*self.init_bat_capacity
        #self.gen.discharge(self.optimisation_res/60*battery_total)
        del  forecasts,actuals,battery_discharge,battery_charge,solar_dispatch,raise6sec,raise60sec,raise5min,raisereg,lower6sec,lower60sec,lower5min,lowerreg,solar_dispatch_vec,battery_energy,battery_discharge_vec,battery_charge_vec,battery_dispatch_vec,raise6sec_disp_vec ,raise60sec_disp_vec,raise5min_disp_vec,raisereg_disp_vec,lower6sec_disp_vec,lower60sec_disp_vec,lower5min_disp_vec,lowerreg_disp_vec,SOC_vec
        gc.collect()         
        pass
    
            
            
            
            